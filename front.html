<div class='container'>
    <div class='expressionContainer'>
        <div class='indicator'></div>
        <span class='expression'>{{Expression}}</span>
    </div>

    <div class='hint'>{{Hint}}</div>
</div>

<script>
    function showRedWarning() {
        // if there's an error somewhere in the other <script>
        // it would never get to hideRedWarning() and we'd see a warning

        let expressionElement = document.querySelector('.expression')
        expressionElement.classList.add('superError')
    }

    showRedWarning()
</script>

<script>
    // ---------------- GLOBAL ----------------

    function defineConstants() {
        riverAnkiNextDayHour = 9

        riverProbabilityReadingHiragana = 0.66

        // --- HANDWRITTEN ---

        riverProbabilityReadingHandwritten = 0.5
        riverProbabilityKanaCardHandwritten = 0.5
        riverProbabilityNewKanjiCardHandwritten = 0.001
        riverProbabilityKanjiCardHandwritten = 0.05

        // --- BLOOD MOON ---

        riverProbabilityBloodMoon = 0.02
        riverBloodMoonProbabilityReadingHandwritten = 0.9
        riverBloodMoonProbabilityKanaCardHandwritten = 0.9
        riverBloodMoonProbabilityNewKanjiCardHandwritten = 0.01
        riverBloodMoonProbabilityKanjiCardHandwritten = riverProbabilityKanjiCardHandwritten * 2

        // --- HOLIDAY ---

        riverProbabilityHoliday = 0.02
        riverHolidayProbabilityNewKanjiCardHandwritten = 0
        riverHolidayProbabilityHandwritten = 0.01

        // --- PREVIEW ---

        riverUsePreview = true
        riverPreviewProbabilityBloodMoon = 0
        riverPreviewProbabilityHoliday = 0
        riverPreviewProbabilityHandwritten = 0.01

        // --- KEYBINDS ---

        riverToggleBlurKey = 'j'
        riverToggleHandwrittenKey = 'h'
    }

    function definePreviewVariables() {
        riverIsPreview = riverUsePreview && getIsPreview()
        if (!riverIsPreview) {
            return
        }

        riverProbabilityBloodMoon = riverPreviewProbabilityBloodMoon
        riverProbabilityHoliday = riverPreviewProbabilityHoliday
    }

    function defineCardVariables() {
        // backticks to avoid single and double quotes in anki fields escaping the string literal
        cardExpression = `{{Expression}}`
        cardHint = `{{Hint}}`
        cardTrueReading = `{{Reading}}`
        cardMeaning = `{{Meaning}}`
        cardNotes = `{{Notes}}`
        cardTrueContext = `{{Context}}`
        cardPitchPosition = `{{PitchPosition}}`

        // additional anki fields addon
        let cardType = `{{info-Type:}}`

        cardIsNew = cardType === '0'
        let cardIsLearning = cardType === '1'
        cardIsReview = cardType === '2'
        // let cardIsRelearning = cardType === '3'

        cardIsNewOrLearning = cardIsNew || cardIsLearning

        cardReading = cardTrueReading === '' ? cardExpression : cardTrueReading
        cardContext = cardTrueContext === '' ? cardExpression : cardTrueContext

        riverIsFrontOfCard = getIsFrontOfCard()
        riverIsKatakanaCard = getIsKatakanaCard(cardExpression)
        riverIsKanaCard = cardReading === cardExpression
    }

    function defineRandomVariables() {
        let random = getRandom(cardContext)
        let cardAgnosticRandom = getRandom('')

        riverIsBloodMoon = cardAgnosticRandom() < riverProbabilityBloodMoon
        riverIsHoliday = riverIsBloodMoon ? false : (cardAgnosticRandom() < riverProbabilityHoliday)

        riverIsHiraganaReading = random() < riverProbabilityReadingHiragana
        riverIsHandwrittenReading = random() < getProbabilityReadingHandwritten()
        riverIsHandwrittenCard = random() < getProbabilityCardHandwritten()

        riverVariedKanaReading = getVariedKanaReading()
    }

    function defineGlobalVariables() {
        defineConstants()
        definePreviewVariables()
        defineCardVariables()
        defineRandomVariables()
    }

    // ---------------- MISC ----------------

    function blurMeaning() {
        let meaningElements = document.querySelectorAll('.meaning, .definitionMeaning, .simpleNoteLine')

        if (cardIsReview) {
            meaningElements.forEach(element => {
                element.classList.add('blurry')
            })
        }

        addEventListener('keypress', (e) => {
            if (e.key === riverToggleBlurKey) {
                meaningElements.forEach(element => {
                    element.classList.toggle('blurry')
                })
            }
        })
    }

    function getIsFrontOfCard() {
        let dividerElement = document.querySelector('.divider')
        return dividerElement === null
    }

    function getIsPreview() {
        // let viewportWidth = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0)
        let viewportHeight = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0)

        // review viewport: (969, 892)
        // preview viewport: (887, 829)
        return viewportHeight < 850
    }

    function getProbabilityReadingHandwritten() {
        if (riverIsBloodMoon) {
            return riverBloodMoonProbabilityReadingHandwritten
        }

        if (riverIsHoliday) {
            return riverHolidayProbabilityHandwritten
        }

        return riverProbabilityReadingHandwritten
    }

    function getProbabilityCardHandwritten() {
        if (riverIsPreview) {
            return riverPreviewProbabilityHandwritten
        }

        if (riverIsHoliday) {
            if (cardIsNewOrLearning && !riverIsKanaCard) {
                return riverHolidayProbabilityNewKanjiCardHandwritten
            }
            
            return riverHolidayProbabilityHandwritten
        }

        if (riverIsKanaCard) {
            if (riverIsBloodMoon) {
                return riverBloodMoonProbabilityKanaCardHandwritten
            }

            return riverProbabilityKanaCardHandwritten
        }
        
        if (cardIsNewOrLearning) {
            if (riverIsBloodMoon) {
                return riverBloodMoonProbabilityNewKanjiCardHandwritten
            }

            return riverProbabilityNewKanjiCardHandwritten
        }

        if (riverIsBloodMoon) {
            return riverBloodMoonProbabilityKanjiCardHandwritten
        }

        return riverProbabilityKanjiCardHandwritten
    }

    function getRandom(context) {
        let getRandomSeed = () => {
            // different seed every day for each card

            let ankiNextDayHour = riverAnkiNextDayHour

            let oneDayMs = 24 * 60 * 60 * 1000
            let date = new Date()
            let timeMs = date.getTime() - date.getTimezoneOffset() * 60 * 1000
            let adjustedTimeMs = timeMs - ankiNextDayHour * 60 * 60 * 1000
            let adjustedDay = Math.floor(adjustedTimeMs / oneDayMs)

            let numberForToday = adjustedDay % 10000
            let cardNumber = [...context].map(c => c.charCodeAt(0)).reduce((a, b) => a + b, 0) % 10000

            return numberForToday + cardNumber
        }

        let seed = getRandomSeed()
        return () => {
            let x = Math.sin(seed++) * 10000
            return x - Math.floor(x)
        }
    }

    function translateKana(source, toHiragana) {
        let hira = "ぁあぃいぅうぇえぉおかがきぎくぐけげこごさざしじすずせぜそぞただちぢっつづてでとどなにぬねのはばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆょよらりるれろゎわゐゑをんゔゕゖゝゞ";
        let kata = "ァアィイゥウェエォオカガキギクグケゲコゴサザシジスズセゼソゾタダチヂッツヅテデトドナニヌネノハバパヒビピフブプヘベペホボポマミムメモャヤュユョヨラリルレロヮワヰヱヲンヴヵヶヽヾ";

        let getIndices = (word, kana) => {
            return word.map(char => {
                let i = kana.indexOf(char)
                return i === -1 ? char : i
            })
        }

        let word = [...source]
        word = getIndices(word, hira)
        word = getIndices(word, kata)

        let targetKana = toHiragana ? hira : kata
        return word.map(i => typeof i === 'number' ? targetKana[i] : i).join('')
    }

    // ---------------- VARIATION ----------------

    function getVariedKanaReading() {
        if (cardReading.includes('ー')) { // katakana prolongation mark
            return cardReading
        }

        return translateKana(cardReading, riverIsHiraganaReading)
    }

    function varyReadingKana() {
        let readingElement = document.querySelector('.reading')
        readingElement.innerHTML = riverVariedKanaReading
    }

    function varyJapaneseFont() {
        varyCardJapaneseFont()
        // varyReadingJapaneseFont()
    }

    function varyCardJapaneseFont() {
        let fontElementSelector = '.expression, .hint, .contextInner, .definitionExpression, .definitionReading'
        let fontElements = document.querySelectorAll(fontElementSelector)

        let toggleHandwritten = () => {
            fontElements.forEach((element) => {
                element.classList.toggle('handwritten')
            })
        }

        if (riverIsHandwrittenCard) {
            toggleHandwritten()
        }

        // let elements = document.querySelectorAll('.image, .context')
        // elements.forEach((element) => {
        //     element.addEventListener('mouseenter', (e) => {
        //         toggleHandwritten()
        //     })

        //     element.addEventListener('mouseleave', (e) => {
        //         toggleHandwritten()
        //     })
        // })

        addEventListener('keypress', (e) => {
            if (e.key === riverToggleHandwrittenKey) {
                toggleHandwritten()
            }
        })
    }

    function varyReadingJapaneseFont() {
        let readingElement = document.querySelector('.reading')
        if (!readingElement) {
            return
        }

        let toggleHandwritten = () => {
            readingElement.classList.toggle('handwritten')
        }

        if (riverIsHandwrittenReading) {
            toggleHandwritten()
        }

        // let elements = document.querySelectorAll('.image, .context')
        // elements.forEach((element) => {
        //     element.addEventListener('mouseenter', (e) => {
        //         toggleHandwritten()
        //     })

        //     element.addEventListener('mouseleave', (e) => {
        //         toggleHandwritten()
        //     })
        // })

        addEventListener('keypress', (e) => {
            if (e.key === riverToggleHandwrittenKey) {
                toggleHandwritten()
            }
        })
    }

    function indicateCard() {
        let indicatorElement = document.querySelector('.indicator')

        if (riverIsPreview) {
            indicatorElement.classList.add('visibleIndicator', 'indicatorPreview')
            return
        }

        if (cardIsNew) {
            indicatorElement.classList.add('visibleIndicator', 'indicatorNew')
            return
        }
    }

    function getIsKatakanaCard(expression) {
        let isKatakana = w => [...w].some(c => c.charCodeAt(0) >= 12449 && c.charCodeAt(0) <= 12534)
        return isKatakana(expression)
    }

    function hideRedWarning() {
        let expressionElement = document.querySelector('.expression')
        expressionElement.classList.remove('superError')
    }

    // ---------------- LINK ADDING ----------------

    function makeDictionaryLinkElement(expression, rawContent) {
        // let link = `https://jisho.org/search/${expression}`
        let link = `https://jpdb.io/search?q=${expression}`

        let linkElement = document.createElement('a')
        linkElement.setAttribute('href', link)
        linkElement.innerHTML = rawContent ?? expression

        return linkElement
    }

    function makeImmersionkitLinkElement(text) {
        let link = `https://www.immersionkit.com/dictionary?keyword=${cardExpression}`

        let linkElement = document.createElement('a')
        linkElement.setAttribute('href', link)
        linkElement.innerHTML = text

        return linkElement
    }

    function addLinkToExpression() {
        let useFurigana = false
        let expressionElement = document.querySelector('.expression')

        let rawExpression = useFurigana ? makeFuriganaExpression(cardExpression, cardReading) : null
        let linkElement = makeDictionaryLinkElement(cardExpression, rawExpression)

        expressionElement.replaceChildren(linkElement)
    }

    function addLinkToReading() {
        let readingElement = document.querySelector('.reading')
        let currentReading = readingElement.innerHTML
        let linkElement = makeImmersionkitLinkElement(currentReading)

        readingElement.replaceChildren(linkElement)
    }

    // ---------------- COPYING ----------------

    function fixCopypaste() {
        let expressionElement = document.querySelector('.expression')
        expressionElement.oncopy = (e) => {
            e.clipboardData.setData('text/plain', cardExpression)
            e.preventDefault()
        }
    }

    // ---------------- FIELD POPULATION ----------------

    function populateReading() {
        let readingElement = document.querySelector('.reading')
        if (readingElement.childNodes.length > 0) {
            return
        }

        readingElement.innerHTML = cardExpression
    }

    function populateContext() {
        let contextInnerElement = document.querySelector('.contextInner')
        if (contextInnerElement.childNodes.length > 0) {
            return
        }

        contextInnerElement.innerHTML = cardExpression
    }

    function populateHint() {
        let removeHintSymbol = '-'
        let copyFromContextSymbol = 'c'

        let hintElement = document.querySelector('.hint')

        if (cardHint === removeHintSymbol) {
            hintElement.innerHTML = ''
            return
        } else if (cardHint === copyFromContextSymbol) {
            hintElement.innerHTML = cardContext
            return
        }

        // if (hintElement.childNodes.length > 0) {
        //     return
        // }

        // if (!riverIsKanaCard || riverIsKatakanaCard) {
        //     return
        // }

        // hintElement.innerHTML = cardContext
    }

    // ---------------- EXPRESSION MARKING ----------------

    function getUnhighlightedIndices(context, expression, specialTagStart, specialTagEnd) {
        let index = 0
        let unhighlightedIndices = []

        while (true) {
            let expressionIndex = context.indexOf(expression, index)
            if (expressionIndex === -1) {
                break
            }

            let startTagIndex = context.indexOf(specialTagStart, index)

            if (startTagIndex === -1 || expressionIndex < startTagIndex) {
                unhighlightedIndices.push(expressionIndex)
                index = expressionIndex + expression.length
                continue
            }

            let startTagEndIndex = startTagIndex + specialTagStart.length
            let endTagIndex = context.indexOf(specialTagEnd, startTagEndIndex)
            if (endTagIndex === -1) {
                alert('Found unclosed special tag')
                break
            }

            index = endTagIndex + specialTagEnd.length
        }

        return unhighlightedIndices
    }

    function highlightExpression(context, expression, unhighlightedIndices, highlightTagStart, highlightTagEnd) {
        if (unhighlightedIndices.length === 0) {
            return context
        }

        let result = ''
        let index = 0
        for (let i = 0; i < unhighlightedIndices.length; i++) {
            let middleChunkLeftIndex = unhighlightedIndices[i]
            let middleChunkRightIndex = middleChunkLeftIndex + expression.length

            let leftChunk = context.substring(index, middleChunkLeftIndex)

            let middleChunk = context.substring(middleChunkLeftIndex, middleChunkRightIndex)
            if (middleChunk !== expression) {
                alert('Something went wrong')
            }

            result += leftChunk + highlightTagStart + expression + highlightTagEnd

            if (i + 1 === unhighlightedIndices.length) {
                let rightChunk = context.substring(middleChunkRightIndex, context.length)
                result += rightChunk
            }

            index = middleChunkRightIndex
        }

        return result
    }

    function autoBoldHighlight(context, expression) {
        let boldTagStart = '<b>'
        let boldTagEnd = '</b>'

        let unhighlightedIndices = getUnhighlightedIndices(context, expression, boldTagStart, boldTagEnd)
        let highlighted = highlightExpression(context, expression, unhighlightedIndices, boldTagStart, boldTagEnd)

        return highlighted
    }

    function markExpressionInElement(elementClass) {
        let element = document.querySelector('.' + elementClass)
        if (!element) {
            return
        }

        let context = element.innerHTML
        if (context.length === 0 || cardExpression.length === 0) {
            return
        }

        let expressionHighlighted = autoBoldHighlight(context, cardExpression)

        let hiraganaReading = translateKana(cardReading, true)
        let katakanaReading = translateKana(cardReading, false)

        let readingHighlighted
        if (cardReading === cardExpression) {
            readingHighlighted = expressionHighlighted
        } else {
            readingHighlighted = autoBoldHighlight(expressionHighlighted, cardReading)
        }

        if (cardReading !== hiraganaReading) {
            readingHighlighted = autoBoldHighlight(readingHighlighted, hiraganaReading)
        }

        if (cardReading !== katakanaReading) {
            readingHighlighted = autoBoldHighlight(readingHighlighted, katakanaReading)
        }

        element.innerHTML = readingHighlighted
    }

    function markContextExpression() {
        markExpressionInElement('hint')
        markExpressionInElement('context')
    }

    // ---------------- ERROR CHECKING ----------------

    function checkHasWhitespaceOrEntity(targetString) {
        let hasWhitespaceAtEdges = targetString !== targetString.trim()
        let hasEntity = /\&[a-z]+;/.test(targetString) // &nbsp; and stuff

        return hasWhitespaceAtEdges || hasEntity
    }

    function checkHasSimpleError(targetString) {
        let hasWhitespaceOrEntity = checkHasWhitespaceOrEntity(targetString)
        let hasTag = /<\/?[a-z][\s\S]*>/i.test(targetString) // <br> and stuff

        return hasWhitespaceOrEntity || hasTag
    }

    function checkHasSentenceError(targetString) {
        let hasWhitespaceOrEntity = checkHasWhitespaceOrEntity(targetString)
        let hasNonBoldTag = /<\/?(?!b>)[a-z][\s\S]*>/i.test(targetString)

        return hasWhitespaceOrEntity || hasNonBoldTag
    }

    function highlightAsErroredIfNeeded(hasError, targetClass) {
        if (!hasError) {
            return
        }

        let targetElement = document.querySelector('.' + targetClass)
        if (!targetElement) {
            return
        }

        targetElement.classList.add('errorField')
    }

    function highlightErrorInExpression() {
        let targetClass = 'expression'
        let targetString = cardExpression

        let hasError = checkHasSimpleError(targetString)
        highlightAsErroredIfNeeded(hasError, targetClass)
    }

    function highlightErrorInReading() {
        let targetClass = 'reading'
        let targetString = cardTrueReading

        let hasError = checkHasSimpleError(targetString)
        highlightAsErroredIfNeeded(hasError, targetClass)
    }

    function highlightErrorInMeaning() {
        let targetClass = 'meaning'
        let targetString = cardMeaning

        let hasError = checkHasSimpleError(targetString)
        highlightAsErroredIfNeeded(hasError, targetClass)
    }

    function highlightErrorInNotes() {
        let targetClass = 'notes'
        let targetString = cardNotes

        let hasWhitespaceAtEdges = targetString !== targetString.trim()
        let hasNonNbspEntity = /\&(?!nbsp)[a-z]+;/.test(targetString) // &nbsp; is ok
        let hasNonBrTag = /<\/?(?!br)[a-z][\s\S]*>/i.test(targetString) // all tags except <br>
        let hasBrAtEdges = /^(<br>.*|.*<br>)$/i.test(targetString)

        let hasError = hasWhitespaceAtEdges || hasNonNbspEntity || hasNonBrTag || hasBrAtEdges
        highlightAsErroredIfNeeded(hasError, targetClass)
    }

    function highlightErrorInContext() {
        let targetClass = 'context'
        let targetString = cardTrueContext

        let hasError = checkHasSentenceError(targetString)
        highlightAsErroredIfNeeded(hasError, targetClass)
    }

    function highlightErrorInHint() {
        let targetClass = 'hint'
        let targetString = cardHint

        let hasError = checkHasSentenceError(targetString)
        highlightAsErroredIfNeeded(hasError, targetClass)
    }

    // ---------------- NOTE DEFINITION HIGHLIGHTING ----------------

    function checkIsKana(c) {
        // src: https://stackoverflow.com/a/43419070
        return /[\u3040-\u30ff]/.test(c)
    }

    function splitIntoKanaGroups(expression) {
        let groups = []
        let chars = [...expression]
        let previousIsKana

        for (let i = 0; i < chars.length; i++) {
            let char = chars[i]
            let isKana = checkIsKana(char)

            if (i === 0) {
                previousIsKana = isKana
                groups.push(char)
                continue
            }

            if (previousIsKana === isKana) {
                groups[groups.length - 1] = groups.at(-1) + char
            } else {
                groups.push(char)
            }

            previousIsKana = isKana
        }

        return groups
    }

    function recognizeReading(kanaGroups, expression, reading) {
        let rawRegex = kanaGroups.map(g => checkIsKana(g) ? g : '(.+)').join('')
        let furiganaRegex = new RegExp(rawRegex)

        let recognized = furiganaRegex.exec(reading)
        if (recognized === null) {
            return [[expression, reading]]
        }

        let recognizedReadings = recognized.slice(1)
        return kanaGroups.map(g => checkIsKana(g) ? [g] : [g, recognizedReadings.shift()])
    }

    function formatRecognized(recognizedGroups) {
        let rubyInner = recognizedGroups.map(group => {
            let element = group[0]
            let reading = group[1] ?? ''
            let switchedReading = translateKana(reading, riverIsHiraganaReading)

            return `${element}<rt>${switchedReading}</rt>`
        })

        return `<ruby>${rubyInner.join('')}</ruby>`
    }

    function makeFuriganaExpression(expression, reading) {
        if (reading === expression || reading === '') {
            return expression
        }

        let kanaGroups = splitIntoKanaGroups(expression)
        let recognizedGroups = recognizeReading(kanaGroups, expression, reading)

        return formatRecognized(recognizedGroups)
    }

    function highlightNoteDefinition(expression, reading, meaning) {
        let useFurigana = true

        let lineElement = document.createElement('span')
        lineElement.classList.add('definitionLine')

        let expressionElement = document.createElement('span')
        expressionElement.classList.add('definitionExpression')

        if (useFurigana) {
            let expressionWithFurigana = makeFuriganaExpression(expression, reading)
            let linkElement = makeDictionaryLinkElement(expression, expressionWithFurigana)
            expressionElement.appendChild(linkElement)

            lineElement.appendChild(expressionElement)
            lineElement.appendChild(document.createTextNode(' — '))
        } else {
            let linkElement = makeDictionaryLinkElement(expression)
            expressionElement.appendChild(linkElement)

            lineElement.appendChild(expressionElement)

            let readingElement = document.createElement('span')
            readingElement.classList.add('definitionReading')
            readingElement.appendChild(document.createTextNode(reading))

            lineElement.appendChild(document.createTextNode('「'))
            lineElement.appendChild(readingElement)
            lineElement.appendChild(document.createTextNode('」— '))
        }

        let meaningElement = document.createElement('span')
        meaningElement.classList.add('definitionMeaning')
        meaningElement.appendChild(document.createTextNode(meaning))

        lineElement.appendChild(meaningElement)
        return lineElement.outerHTML
    }

    function highlightNoteLine(line) {
        // definition examples:
        // 持ち上げる「もちあげる」- elevate, flatter
        // 収まる「おさまる」- fit into

        let definitionRegex = /^(.+?)\s*[「\[](.+)[」\]]\s*[-ー—]\s*(.+)$/

        let groups = definitionRegex.exec(line)
        if (groups === null) {
            let noteLineElement = document.createElement('span')
            noteLineElement.classList.add('simpleNoteLine')
            noteLineElement.appendChild(document.createTextNode(line))

            return {
                isMain: false,
                highlighted: noteLineElement.outerHTML
            }
        }

        let expression = groups[1].trim()
        let reading = groups[2].trim()
        let meaning = groups[3].trim()

        let isMainDefinition = expression == cardExpression && reading == cardReading
        let highlightedDefinition = highlightNoteDefinition(expression, reading, meaning)

        return {
            isMain: isMainDefinition,
            highlighted: highlightedDefinition
        }
    }

    function highlightNoteDefinitions() {
        let removeMainDefinitionNote = true

        let noteElement = document.querySelector('.notes')
        if (noteElement.childNodes.length === 0) {
            return
        }

        let dividerTag = '<br>'
        let noteRaw = noteElement.innerHTML.replaceAll('&nbsp;', ' ').trim()
        let lines = noteRaw.split(dividerTag)

        let highlightedLines = lines.map(line => highlightNoteLine(line))
        if (removeMainDefinitionNote) {
            highlightedLines = highlightedLines.filter(line => !line.isMain)
        }

        highlightedLines = highlightedLines.map(line => line.highlighted)
        let highlightedNote = highlightedLines.join(dividerTag)

        noteElement.innerHTML = highlightedNote
    }

    // ---------------- PITCH ACCENT ----------------

    function getPitchPositions() {
        let positions = cardPitchPosition.match(/^\d+|\d+\b|\d+(?=\w)/g)
        if (positions === null) {
            return null
        }

        return positions.map(a => Number(a))
    }

    function getPitchType(pitchPosition) {
        let moraLength = cardReading.replace(/[ャュョァィゥェォヮゃゅょぁぃぅぇぉゎ]/g, '').length

        if (pitchPosition === 0) {
            return 'heiban'
        } else if (pitchPosition === 1) {
            return 'atamadaka'
        } else if (pitchPosition === moraLength) {
            return 'odaka'
        } else if (pitchPosition === moraLength - 1) {
            return 'kifuku' // not entirely correct but we're letting it slide
        } else {
            return 'nakadaka'
        }
    }
    
    function markPitchInContextExpression() {
        let pitchPositions = getPitchPositions()
        if (!pitchPositions) {
            return
        }

        let pitchType = getPitchType(pitchPositions[0])

        // dont add pitch to hint to not make it easy
        let highlightedElements = document.querySelectorAll('.context b')
        highlightedElements.forEach((element) => {
            element.classList.add('pitch-underline', pitchType)
        })
    }

    function groupMoras(kana) {
        let currentChar = ''
        let nextChar = ''
        let groupedMoras = []
        let check = 'ャュョァィゥェォヮゃゅょぁぃぅぇぉゎ'.split('')

        for (let i = 0; i < kana.length; i++) {
            currentChar = kana[i]
            nextChar = i < kana.length - 1 && kana[i + 1]

            if (check.includes(nextChar)) {
                groupedMoras.push(currentChar + nextChar)
                i += 1
            } else {
                groupedMoras.push(currentChar)
            }
        }

        return groupedMoras
    }

    function getPitchPattern(pitchPosition) {
        let low = '0'
        let high = '1'
        let drop = '2' // high to low

        let moras = groupMoras(cardReading)
        let pitchType = getPitchType(pitchPosition)
        let pattern = []

        if (pitchType === 'heiban') {
            pattern = [
                ...Array(moras[0].length).fill(low),
                ...Array(cardReading.length - moras[0].length).fill(high),
            ]
        } else if (pitchType === 'atamadaka') {
            pattern = [
                ...(moras[0].length === 2 ? [high, drop] : [drop]),
                ...Array(cardReading.length - moras[0].length).fill(low),
            ]
        } else if (pitchType === 'odaka') {
            pattern = [
                ...Array(moras[0].length).fill(low),
                ...Array(cardReading.length - moras[0].length - 1).fill(high),
                drop,
            ]
        } else { // nakadaka
            let afterDrop = false
            for (let i = 0; i < moras.length; i++) {
                if (i === 0) {
                    pattern = Array(moras[0].length).fill(low)
                } else if (i + 1 === pitchPosition) {
                    pattern =
                        moras[i].length === 2
                        ? [...pattern, high, drop]
                        : [...pattern, drop]
                    afterDrop = true
                } else if (afterDrop) {
                    pattern = [...pattern, ...Array(moras[i].length).fill(low)]
                } else {
                    pattern = [...pattern, ...Array(moras[i].length).fill(high)]
                }
            }
        }

        return pattern
    }

    function constructPitchList(pitchPositions) {
        let low = '0'
        let high = '1'
        let drop = '2' // high to low

        let createPitchSpan = (pitchClass, pitchChar) => {
            let pitchSpan = document.createElement('span')
            let charSpan = document.createElement('span')
            let lineSpan = document.createElement('span')

            pitchSpan.classList.add(pitchClass)
            charSpan.classList.add('pitch-char')
            charSpan.innerText = pitchChar
            lineSpan.classList.add('pitch-line')

            pitchSpan.appendChild(charSpan)
            pitchSpan.appendChild(lineSpan)

            return pitchSpan
        }

        let uniquePitchPositions = [...new Set(pitchPositions)]
        let pitchList = document.createElement('ul')

        for (let pitchPosition of uniquePitchPositions) {
            let pattern = getPitchPattern(pitchPosition)
            let pitchType = getPitchType(pitchPosition)

            let pitchItem = document.createElement('li')
            pitchItem.classList.add('pitch-item', pitchType)

            for (let i = 0; i < riverVariedKanaReading.length; i++) {
                let currentKana = riverVariedKanaReading[i]

                let className = null
                if (pattern[i] === low) {
                    className = 'pitch-low'
                }
                else if (pattern[i] === high) {
                    className = 'pitch-high'
                }
                else if (pattern[i] === drop) {
                    className = 'pitch-to-drop'
                } else {
                    // console.error('pattern[i] found undefined value. pattern is', pattern)
                    alert(`pattern[i] found undefined value. pattern is ${pattern}`)
                    break
                }

                let currentPitchSpan = createPitchSpan(className, currentKana)
                pitchItem.appendChild(currentPitchSpan)
            }
            
            pitchList.appendChild(pitchItem)
        }

        return pitchList
    }

    function addPitchToReading() {
        let readingElement = document.querySelector(".reading")
        let pitchPositions = getPitchPositions()
        if (!pitchPositions) {
            return
        }

        let pitchList = constructPitchList(pitchPositions)

        readingElement.innerHTML = ""
        readingElement.appendChild(pitchList)
        readingElement.classList.add('pitch')
    }

    // ---------------- MAIN ----------------

    function mainFront() {
        indicateCard()
        addLinkToExpression()
        fixCopypaste()

        // populateReading()
        // varyReadingKana()
        // addPitchToReading()
        // addLinkToReading()

        // populateContext()
        populateHint()
        markContextExpression()
        // markPitchInContextExpression()

        highlightErrorInExpression()
        // highlightErrorInReading()
        // highlightErrorInMeaning()
        // highlightErrorInNotes()
        // highlightErrorInContext()
        highlightErrorInHint()

        // highlightNoteDefinitions()
        // blurMeaning()
        varyJapaneseFont()
    }

    function mainBack() {
        indicateCard()
        addLinkToExpression()
        fixCopypaste()

        // populateReading()
        varyReadingKana()
        addPitchToReading()
        addLinkToReading()

        populateContext()
        populateHint()
        markContextExpression()
        markPitchInContextExpression()

        highlightErrorInExpression()
        highlightErrorInReading()
        highlightErrorInMeaning()
        highlightErrorInNotes()
        highlightErrorInContext()
        highlightErrorInHint()

        highlightNoteDefinitions()
        blurMeaning()
        varyJapaneseFont()
    }

    function main() {
        defineGlobalVariables()

        if (riverIsFrontOfCard) {
            mainFront()
        } else {
            mainBack()
        }

        hideRedWarning()
    }

    main()
</script>
